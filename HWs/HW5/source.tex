\documentclass{article} 
\usepackage{amsfonts} 
\usepackage{amsmath,amsthm,amssymb} 
\usepackage{mathtext} 
\usepackage[english,russian]{babel} 
\usepackage{setspace} \usepackage{amsmath} 
\usepackage{alltt} 
\begin{document} 
\noindent 
\large 
\onehalfspacing 
\section{Задача №1}
Возьмем сеть сортировки длины $n$, пусть между элементами $i$ и $i+1$ нет компаратора. Подадим на вход нашей сети сортировки последовательность $1,2,...,i-1,i+1,i,i+2,...n$, тогда какие бы компараторы мы не использовали, наша последовательность не изменится, так как в силу отсутствия компаратора между $i$ и $i+1$ наша последовательность является строго возрастающей последовательностью, которую если объединить элементы $i$ и $i+1$ в элемент $j$($i-1<j<i+2$) можно представить так: $1<2<...<i-1<j<i+2<...<n$. А в отсортированной последовательности сортирующая сеть не поменяет ни одного элемента и $i+1$ так и останется левее $i$.
\section{Задача №2}
Данный нам элемент, после слияния с массивом, может стоять на любой из $n$ позиций, и для корректности вставки мы должны сравнить его со всеми позициями. Тогда в первом слое сравним его с каким-нибудь элементом: теперь он может стоять в $2$-х позициях, во втором слое сравним каждую из этих позиций с другими двумя позициями --- теперь элемент может стоять на $4$-x позициях, повторяя эти действия $\log_2{n}$ раз наш элемент сможет стоять на всех $n$ позициях, а при меньшем количестве слоев какие то позиции могли бы остаться недосягаемыми для нашего элемента --- поэтому нам и необходимы минимум $\log_2{n}$ слоев.
\section{Задача №3}
Поймем в каком случае элемент из первой части половины массива попадет во вторую. Последний элемент первого подмассива не будет в $n$ наибольших, если он меньше первого элемента второго подмассива, так $n$ наибольшими будут все элементы второго подмассива. Предпоследний элемент первого массива не будет в $n$ наибольших, если он меньше  второго элемента второго подмассива, так как $n$ наибольшими будут последний элемент первого подмассива и $n-1$ элементов второго подмассива. Повторяя подобные рассуждения для остальных элементов первого массива становится понятно, что нам достаточно $n$ компараторов: $1$ и $2n$, $2$ и $2n-1$,..., $n$ и $n+1$, чтобы в второй половине подмассива стояли $n$ наибольших элементов, а в первой половине соответственно $n$ меньших. Так как каждая позиция массива относится только к одному компаратору, мы может поместить все эти компараторы в один слой, тогда нужное нам количество слоев --- $O(1)$.
\section{Задача №4}
Заметим, что антикомпаратор, для сети из обычных компараторов как бы меняет нитки местами, тоесть например, если у нас был антикомпаратор между нитками $i$ и $j$, в которых были записаны числа $a$ и $b$, то мы можем поменять антикомпаратор на компаратор и поменять нитки местами. Тогда заведем вспомогательный массив $vec[1...n]$, где $n$-количество ниток, тогда в начале заполним массив так $vec[i]=i$, теперь будем идти по слоям, если встречаем компаратор между $i$ и $j$ нитками, то заменяем его на компаратор между $vec[i]$ и $vec[j]$, а если встречаем антикомпаратор между между $i$ и $j$, то заменяем его на компаратор между $vec[i]$ и $vec[j]$ и сделаем $swap(vec[i], vec[j])$.\newline
Докажем корректность: пусть у нас есть антикомпаратор между нитками $i$ и $j$ в которых стоят значения $a$ и $b$ пусть для определенности $a<b$(если не так доказательство аналогично),	 тогда в нитку $i$ будет записано значение $b$, а в нитку $j$ значение $a$, тогда если мы ставим вместо этого антикомпаратора компаратор, то для для последующих компараторов и антикопараторов значения на нитках будут неверны, для этого и поменяем значния $vec]i]$ и $vec[j]$.
\end{document}